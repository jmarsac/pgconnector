/*--------------------------------------------------------------------------------------+
|
|     $Source$
|
|  $Copyright: (c) 2016 Azimut. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------+
|									|
|   $Workfile$
|   $Revision$
|   	$Revision$
|									|
+----------------------------------------------------------------------*/
/*----------------------------------------------------------------------+
|									|
|   Function -								|
|									|
|	MDL program to connect to PostgreSQL/PostGIS database			|
|									|
|	- - - - - - - - - - - - - - - - - - - - - - - - - - - - -	|
|									|
|   Public Routine Summary -						|
|	pgconnector								|
|	pgconnector_findObject - Locate a parcel				|
|	pgconnector_initScanlist - Initialize the scanlist			|
|	pgconnector_loadLabelCommand - Load label command function			|
|	pgconnector_loadTextNode - Load label into a text node	|
|	pgconnector_matchLabelNode - Compare label linkages for match		|
|	pgconnector_readColorMapLine - Read a line from the color mapping file	|
|	pgconnector_rscSprintf - Do sprintf from message list			|
|	pgconnector_scanLabelNode - Scan design file for a label	|
|	pgconnector_setColorFillLinkage - set color of fill linkage		|
|	pgconnector_writeObject - Write object information to the database	|
|	main - main entry point						|
|									|
+----------------------------------------------------------------------*/
#include    <mdl.h>
#include    <mselems.h>
#include    <dlogbox.h>
#include    <dlogitem.h>
#include    <dlogids.h>
#include    <cexpr.h>
#include    <system.h>
#include    <global.h>
#include    <scanner.h>
#include    <tcb.h>
#include    <userfnc.h>
#include    <stdio.h>
#include    <dbdefs.h>
#include    <dberrs.h>
#include    <wchar.h>
#include    <stdarg.h>
#include    <string.h>
#include    <ctype.h>
#include    <toolsubs.h>

#include    "pgconnectorid.h"   /* resource IDs */
#include    "pgconnectorcmd.h"	/* generated by resource compiler */

#include    <dlmsys.fdf>
#include    <dlogman.fdf>
#include    <mselemen.fdf>
#include    <msfile.fdf>
#include    <msdb.fdf>
#include    <mselmdsc.fdf>
#include    <msmisc.fdf>
#include    <msstate.fdf>
#include    <mssystem.fdf>
#include    <msoutput.fdf>
#include    <msrsrc.fdf>
#include    <msparse.fdf>
#include    <msscan.fdf>
#include    <msview.fdf>
#include    <mslocate.fdf>
#include    <msscancrit.fdf>
#include    <msvar.fdf>
#include    <changetrack.fdf>
#include    <msinput.fdf>
/*----------------------------------------------------------------------+
|									|
|   Include Files   							|
|									|
+----------------------------------------------------------------------*/
/*----------------------------------------------------------------------+
|									|
|   Local defines							|
|									|
+----------------------------------------------------------------------*/
#if defined (macintosh)
	#define LINEFEED		13
#else
	#define LINEFEED		10
#endif
#define DISPLAY_ATTRIBUTE_ID	65
#define FILL_ATTRIBUTE		8

/*----------------------------------------------------------------------+
|									|
|   Local type definitions						|
|									|
+----------------------------------------------------------------------*/
typedef struct display_attribute
    {
#if !defined (BITFIELDS_REVERSED)
    UShort	    words:8;
    UShort	    elementClass:4;
    UShort	    user:1;
    UShort	    modified:1;
    UShort	    remote:1;
    UShort	    info:1;
#else
    UShort	info:1;
    UShort	remote:1;
    UShort	modified:1;
    UShort	user:1;
    UShort	elementClass:4;
    UShort	words:8;
#endif
    UShort	    primary_id;
    byte	    attr_length;
    byte	    attr_type;
    short	    color_flag;
    short	    index;
    short	    pad[3];
    } Display_attribute;

#define FILL_ATTRIBUTE		 8
#define TEXTSTYLE_ATTRIBUTE      18

/*----------------------------------------------------------------------+
|									|
|   Public Global variables						|
|									|
+----------------------------------------------------------------------*/
void		(*parcelFunction)();
void		pgconnector_initScanlist ();
Public char	objectNumber[128];
Public char	objectColors[8][32];
Public char	objectColorFile[128];
Public UShort	targetEntity;
Public ULong	targetMslink;
Public long	assessedValue[8];

/*----------------------------------------------------------------------+
|									|
|   External variables							|
|									|
+----------------------------------------------------------------------*/
extern "C" void strpspc(char* chrstr);

/*----------------------------------------------------------------------+
|									|
|   Local function declarations 					|
|									|
+----------------------------------------------------------------------*/
void pgconnector_findObject (void);

/*----------------------------------------------------------------------+
|									|
|   Private Global variables						|
|									|
+----------------------------------------------------------------------*/
Private int silentMode = FALSE;
Private int Nb_elems = 0;

/*ff Major Public Code Section */
/*----------------------------------------------------------------------+
|									|
|   Major Public Code Section						|
|									|
+----------------------------------------------------------------------*/
/*----------------------------------------------------------------------+
|                                                                       |
|   name          pgconnector_currentDesignFile					|
|                                                                       |
|   author        BSI                                       3/90        |
|                                                                       |
+----------------------------------------------------------------------*/
Private void pgconnector_currentDesignFile
(
char	*file	    /* <= design file name */
)
    {
    char    filename[128], extension[32];

    /* extract the file name for the current design file */
    mdlFile_parseName (tcb->dgnfilenm, NULL, NULL, filename, extension);

    /* now put the pieces together */
    strcat (filename, ".");
    strcat (filename, extension);
    strpspc (filename);
    strcpy (file, filename);
    }

/*----------------------------------------------------------------------+
|                                                                       |
|   name          pgconnector_clearAllFields					|
|                                                                       |
|   author        BSI                                       3/90        |
|                                                                       |
+----------------------------------------------------------------------*/
Private void pgconnector_clearAllFields
(
void
)
    {
    /* clear the MicroStation fields */
    mdlOutput_status ("");
    mdlOutput_command ("");
    mdlOutput_error ("");
    mdlOutput_prompt ("");
    mdlOutput_message ("");
    }

/*----------------------------------------------------------------------+
|                                                                       |
|   Name	pgconnector_rscSprintf						|
|                                                                       |
|   Author	BSI                                         3/93        |
|                                                                       |
+----------------------------------------------------------------------*/
Private void pgconnector_rscSprintf
(
char   *stringP,	    /* <=  Result of sprintf from resource	*/
int	messageNumber,	    /*  => Index into msg list for format str	*/
...			    /*  => Any other optional arguments		*/
)
    {
    va_list ap;
    char    tempStr[1024];

    va_start (ap, messageNumber);

    *stringP = tempStr[0] = '\0';
    mdlResource_loadFromStringList (tempStr, NULL, MESSAGELISTID_PGCONNECTORMessages,
				    messageNumber);
    vsprintf (stringP, tempStr, ap);

    va_end (ap);
    }

/*----------------------------------------------------------------------+
|                                                                       |
| name          pgconnector_writeObject						|
|                                                                       |
| author        BSI                                     3/90            |
|                                                                       |
+----------------------------------------------------------------------*/
Private void pgconnector_writeObject
(
void
)
    {
    char	    filename[128], mslinkString[64];
    char	    mapID[32], sqlStatement[128];
    int		    status;
    MSElementUnion  u;
    ULong	    filePosition, mslinkKey;

    /* our element is now in DGNBUF */
    mdlDB_attachActiveEntityElement (&u, dgnBuf);

    filePosition = mdlElement_getFilePos (FILEPOS_CURRENT, 0);
    mdlElement_rewrite (&u, dgnBuf, filePosition);

    /* refresh the element */
    mdlElement_display (&u, NORMALDRAW);
    mdlOutput_rscPrintf (MSG_MESSAGE, NULL, MESSAGELISTID_PGCONNECTORMessages, 6);

    /* now update the parcel row with the MAPID for current design file */
    /* first, get the file name for the current design file */
    pgconnector_currentDesignFile (filename);

    /* now extract the MSLINK key from the maps table for this file */
    sprintf (sqlStatement,
             "select mslink from maps where mapname = '%s'", filename);
    mdlOutput_rscPrintf (MSG_MESSAGE, NULL, MESSAGELISTID_PGCONNECTORMessages, 7);
    status = mdlDB_sqlQuery (mapID, sqlStatement);

    /* now update the parcel row with this MAPID */
    sprintf (sqlStatement,
	     "select mslink from parcel where clt_no = '%s'", objectNumber);
    mdlDB_sqlQuery (mslinkString, sqlStatement);
    mslinkKey = (ULong) atol (mslinkString);

    mdlOutput_rscPrintf (MSG_MESSAGE, NULL, MESSAGELISTID_PGCONNECTORMessages, 8);
    mdlDB_writeColumn ("parcel", mslinkKey, "mapid", mapID);
    mdlOutput_rscPrintf (MSG_MESSAGE, NULL, MESSAGELISTID_PGCONNECTORMessages, 9);

    /* reset our state to the default for this command */
    //pgconnector_setAttachParcelState();
    }

/*----------------------------------------------------------------------+
|                                                                       |
| name          pgconnector_findObject						|
|                                                                       |
| author        BSI                                       3/90          |
|                                                                       |
+----------------------------------------------------------------------*/
Private void pgconnector_findObject
(
void
)
    {
    char    sqlStatement[128];
    int	    status= ERROR;
	int  parcelLocated=0;

    /* active entity does not correspond to target parcel */
    if (!parcelLocated)
	{
	/* build an SQL statement to find this parcel */
	sprintf (sqlStatement,
		"select * from parcel where clt_no = '%s'", objectNumber);

	mdlOutput_rscPrintf (MSG_MESSAGE, NULL, MESSAGELISTID_PGCONNECTORMessages, 4);
	mdlOutput_prompt ("");

	/* set up the active entity based on the parcel number */
	status = mdlDB_defineAEBySQLSelect (sqlStatement);
	}

    if (status == SUCCESS)
	{
	/* active entity represents the target parcel */
	parcelLocated = TRUE;

	mdlLocate_noElemNoLocked ();
	/* set search mask for lines only */
	tcb->searchType[0] = 0x0004;
	tcb->searchType[1] = 0x0000;

	mdlState_startModifyCommand (pgconnector_findObject, pgconnector_writeObject, NULL, NULL,
				     NULL, 0, 0, 0, 0);
	mdlOutput_rscPrintf (MSG_PROMPT, NULL, MESSAGELISTID_PGCONNECTORMessages, 5);
	tcb->restartLocate = FALSE;
	}
    }

/*----------------------------------------------------------------------+
|                                                                       |
| name          pgconnector_matchObject						|
|                                                                       |
| author        BSI                                       3/90          |
|                                                                       |
+----------------------------------------------------------------------*/
Private int pgconnector_matchObject
(
Dpoint3d	*origin,	    /* <= origin of the parcel */
MSElementUnion	*p		    /* => element to compare */
)
    {
    int		    status=0, numVertices=0, linkCount=0, loopCount=0;
    DatabaseLink    *link=NULL;

    /* check if this attribute linkage belongs to us */
    if (mdlDB_elementFilter (p))
	{
	status = mdlDB_extractLinkages (&link, &linkCount, p);

	if (status == SUCCESS)
	    {
	    for (loopCount=0; loopCount < linkCount; ++loopCount)
		{
		/* do we have a match on the parcel entity number and mslink? */
		if ((link[loopCount].entity == targetEntity) && (link[loopCount].mslink == targetMslink))
		    {
		    DgnModelRefP    modelRef;

		    mdlElement_getFilePos (FILEPOS_CURRENT, &modelRef);
		    mdlLinear_extract (origin, &numVertices, p, modelRef);
		    return (SUCCESS);
		    }
		}
	    }
        }    
     
    return (ERROR);
    }

/*----------------------------------------------------------------------+
|									|
| name		pgconnector_scanObject						|
|									|
| author	BSI     				3/90		|
|									|
+----------------------------------------------------------------------*/
Private int pgconnector_scanObject
(
Dpoint3d	    *origin,    /* <= origin of the parcel */
MSElementUnion	    *parcel	/* <= target parcel */
)
    {
    ScanCriteria	*pScanCriteria = NULL;
    ExtendedAttrBuf     extAttrBuf;
    int			scanStatus, acceptSize, status;
    UInt32              scanBuffer[1024], scanPosition, *lP;
    UShort		typeMaskArray[8];    
    
        
    pScanCriteria = mdlScanCriteria_create();
    
    /* Setup to return FilePositions. Set NestCells to be TRUE */
    mdlScanCriteria_setReturnType(pScanCriteria, MSSCANCRIT_RETURN_FILEPOS, FALSE, TRUE);
    
    mdlScanCriteria_setAttributeTest (pScanCriteria, 0, 0, &extAttrBuf);
    
    
    /* set the type mask to scan only for type 3 (lines) */
    memset(typeMaskArray, 0, sizeof(typeMaskArray));
    typeMaskArray[0] = 0x0004;
    typeMaskArray[1] = 0x0000;
    mdlScanCriteria_setElementTypeTest(pScanCriteria, typeMaskArray,sizeof (typeMaskArray));
    
    
    mdlScanCriteria_setDrawnElements(pScanCriteria);
        
    mdlScanCriteria_setModel (pScanCriteria, MASTERFILE);
			    
    do
	{
	acceptSize = sizeof (scanBuffer) / sizeof (short);
	scanStatus = mdlScanCriteria_scan(pScanCriteria, (void *) scanBuffer, &acceptSize, &scanPosition);

	for (lP = scanBuffer; lP<scanBuffer+acceptSize/2 ; lP++)
	    {
            
            status = mdlElement_read (parcel, MASTERFILE, *lP);
            
	    if (SUCCESS == status)
		{
		/* check if element contains the desired attribute linkage */
		if (pgconnector_matchObject (origin, parcel) == SUCCESS)
		    return (SUCCESS);

		}
	    }
	}  while (scanStatus == 11 );

    return (ERROR);
    }

/*----------------------------------------------------------------------+
|                                                                       |
| name          pgconnector_setColorFillLinkage					|
|                                                                       |
| author        BSI                                       4/90          |
|                                                                       |
+----------------------------------------------------------------------*/
Private void pgconnector_setColorFillLinkage
(
MSElement      *element,	/* <=> the element to operate on */
void	       *params,		/*  => parm from the call to operation */
int		operation,	/*  => flag for reason called */
ULong		offset,		/*  => offset from header */
MSElementDescr *elemDscrP	/*  => element descr */
)
    {
    long    pinColor;
    
    pinColor = *((long *) params);
    
    if (pinColor >= 0) element->hdr.dhdr.symb.color = pinColor;
	mdlElement_setFillColor (element, pinColor);
    }


/*----------------------------------------------------------------------+
|                                                                       |
| name          pgconnector_readColorMapLine					|
|                                                                       |
| author        BSI                                       4/90          |
|                                                                       |
+----------------------------------------------------------------------*/
Private int pgconnector_readColorMapLine
(
char	*line,
FILE	*fp
)
    {
    char    *p;
    char    rawLine[128];
    int	    charsRead;

    /* fgets() is not supported yet */
    for (p = rawLine;; p++)
	{
	charsRead = fread (p, sizeof(char), 1, fp);
	/* end of file reached */
	if (charsRead != 1) return (ERROR);
	if (*p == LINEFEED)
	    {
	    *p = '\0';
	    strcpy (line, rawLine);
	    return (SUCCESS);
	    }
	}
    return (ERROR);
    }


/*----------------------------------------------------------------------+
|                                                                       |
| name          pgconnector_initScanlist					|
|                                                                       |
| author	BSI				    2/91		|
|                                                                       |
+----------------------------------------------------------------------*/
Private void pgconnector_initScanlist
(
Scanlist	*scanList
)
    {
    /* initialize the entire scan list to zero */
    memset ((char *) scanList, 0, sizeof (Scanlist));

    /* set the scan list length (should always be same) */
    scanList->sllen = 0x1000 + sizeof (Scanlist)/2;
    }

/*----------------------------------------------------------------------+
|									|
| name		pgconnector_loadTextNode					|
|									|
| author	BSI     				6/92		|
|									|
+----------------------------------------------------------------------*/
Private void pgconnector_loadTextNode
(
MSElementDescr	**elemDscrPP,	    /* <=  element descr of node to load    */
ULong		filePos		    /*  => file position		    */
)
    {
    MSElementDescr  *oldDscrP;

    mdlElmdscr_duplicate (&oldDscrP, *elemDscrPP);
    mdlDB_loadDADscr (elemDscrPP);

    mdlElmdscr_rewrite (*elemDscrPP, oldDscrP, filePos);
    mdlElmdscr_display (oldDscrP, 0, ERASE);
    mdlElmdscr_display (*elemDscrPP, 0, NORMALDRAW);

    mdlElmdscr_freeAll (&oldDscrP);
    }

/*----------------------------------------------------------------------+
|                                                                       |
| name          pgconnector_matchLabelNode					|
|                                                                       |
|		Check whether linkage for this DAS text node equals     |
|               linkage being searched for.  If mslink is 0, check	|
|		only the entity number.					|
|                                                                       |
| author        BSI                                       6/92          |
|                                                                       |
+----------------------------------------------------------------------*/
Private int pgconnector_matchLabelNode
(
MSElementDescr	**elemDscrPP,
ULong		entity,
ULong		mslink,
ULong		filePos
)
    {
    int		    status=0, linkCount=0, loopCount=0;
    UInt32          actualFilePos=0;
    DatabaseLink    *link=NULL;
    MSElementUnion  *hdrEltP;

    mdlElmdscr_read (elemDscrPP, filePos, MASTERFILE, FALSE, &actualFilePos);

    hdrEltP = &(*elemDscrPP)->el;

    /* check if this attribute linkage belongs to us */
    if (mdlDB_elementFilter (hdrEltP))
	{
	status = mdlDB_extractLinkages (&link, &linkCount, hdrEltP);

	if (status == SUCCESS)
	    {
	    for (loopCount=0; loopCount < linkCount; ++loopCount)
		{
		/* do we have a match on the parcel entity number and mslink? */
		if ((link[loopCount].entity == (UShort) entity) && 
		    ((mslink == 0L) || (link[loopCount].mslink == mslink)))
		    {
                    //mdlElmdscr_freeAll (elemDscrPP);
		    return (SUCCESS);
		    }
		}
	    }
        }    
     
    mdlElmdscr_freeAll (elemDscrPP);
    return (ERROR);
    }

/*----------------------------------------------------------------------+
|									|
|   Command functions							|
|									|
+----------------------------------------------------------------------*/
/*----------------------------------------------------------------------+
|									|
| name		pgconnector_scanLabelNode						|
|									|
| author	BSI     				6/92		|
|									|
+----------------------------------------------------------------------*/
/*cmdName*/ void pgconnector_scanLabelNode
(
ULong	    entity,
ULong	    mslink
)
    {
    MSElementDescr      *elemDscrP;
    ScanCriteria	*pScanCriteria = NULL;
    ExtendedAttrBuf     extAttrBuf;
    int			scanStatus, acceptSize;
    UInt32              scanBuffer[1024], scanPosition, *lP;
    UShort		typeMaskArray[8];    
            
    
    pScanCriteria = mdlScanCriteria_create();
    
    /* Setup to return FilePositions. Set NestCells to be TRUE */
    mdlScanCriteria_setReturnType(pScanCriteria, MSSCANCRIT_RETURN_FILEPOS, FALSE, TRUE);
    
    mdlScanCriteria_setAttributeTest (pScanCriteria, 0, 0, &extAttrBuf);
    
    
    /* set the type mask to scan only for type 3 (lines) */
    memset(typeMaskArray, 0, sizeof(typeMaskArray));
    typeMaskArray[0] = TMSK0_TEXT_NODE;
    typeMaskArray[1] = 0x0000;
    mdlScanCriteria_setElementTypeTest(pScanCriteria, typeMaskArray,sizeof (typeMaskArray));
    
    
    mdlScanCriteria_setDrawnElements(pScanCriteria);
        
    mdlScanCriteria_setModel (pScanCriteria, MASTERFILE);
			    
    do
	{
	acceptSize = sizeof (scanBuffer) / sizeof (short);
	scanStatus = mdlScanCriteria_scan(pScanCriteria, (void *) scanBuffer, &acceptSize, &scanPosition);

	for (lP = scanBuffer; lP<scanBuffer+acceptSize/2 ; lP++)
	    {
            /* check if element contains the desired attribute linkage */
	    if (pgconnector_matchLabelNode (&elemDscrP, entity, mslink, *lP) == SUCCESS)
	        {
	        pgconnector_loadTextNode (&elemDscrP, *lP);
	        mdlElmdscr_freeAll (&elemDscrP);
	        }
	    }
	}  while (scanStatus == BUFF_FULL);

    return;
    
    }

/*----------------------------------------------------------------------+
|									|
| name		pgconnector_setSearchCriteria						|
|									|
| author	BSI     				3/90		|
|									|
+----------------------------------------------------------------------*/
Private void    pgconnector_setSearchCriteria
(
void
)
    {
    static int  searchType[] = {LINE_ELM,};

    /* Clear search criteria */
    mdlLocate_noElemAllowLocked ();

    /* Set search mask to look for line elements */
    mdlLocate_setElemSearchMask (sizeof(searchType)/sizeof(int), searchType);
    
    }


/*----------------------------------------------------------------------+
|									|
| name		pgconnector_loadLabelCommand					|
|									|
|		Call scanDASNode with entity and mlink user has		|
|		provided.						|
|									|
| author	BSI     				6/92		|
|									|
+----------------------------------------------------------------------*/
/*cmdName*/ void pgconnector_loadLabelCommand
(
char	*unparsed
)
//cmdNumber CMD_PARCEL_LOADDAS
    {
    char	*entity, *mslink;
    char	query[128], queryResult[32];
    UShort	entityNum;
    ULong	mslinkNum;
    wchar_t     wChar;

    entity = strtok (unparsed, " ");
    if (!entity)
	return;

    /* if user supplies no mslink or *, load all text nodes for this entity */
    mslink = strtok (NULL, " ");
    if (!mslink || mslink[0] == '*')
	mslinkNum = 0L;
    else
	mslinkNum = atol (mslink);

    /* check if user has provided entity name or number */
    mbtowc (&wChar, entity, 10);
    if (iswalpha (wChar))
	{
	sprintf (query,
	         "select entitynum from mscatalog where tablename = '%s'",
		 entity);
	mdlDB_sqlQuery (queryResult, query);
	entity = queryResult;
	}

    entityNum = (UShort)atoi (entity);

    mdlOutput_rscPrintf (MSG_ERROR, NULL, MESSAGELISTID_PGCONNECTORMessages, 24);
    pgconnector_scanLabelNode (entityNum, mslinkNum);
    mdlOutput_rscPrintf (MSG_ERROR, NULL, MESSAGELISTID_PGCONNECTORMessages, 25);
    }
/*MAN______________________________________________________________________

NOM undoRedoProcessAddOrChange: traite les undo/redo des éléments créés

DESCRIPTION

SYNOPSIS

VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Private void undoRedoProcessAddOrChange(MSElementDescr *new_edP,MSElementDescr *old_edP,ChangeTrackInfo *info,BoolInt *cant_be_undone)
{
   MSElement *elP = NULL;

   //char str[80];
   int elem_type;
   int fl_elem_ok=0;
   ULong filepos;
   /*
   int i,j;
   int n;
   int nb_pts;
   DPoint3d line_pts[2];
   DPoint3d new_pt;
   DPoint3d translation;
   MSElement element;
   PtopoName nom;
   Transform tmatrix;
   ULong filepos_arr[50];
   OwnMSWChar cell_name[MAX_CELLNAME_LENGTH+1];
*/
   MSElementDescr *edP = NULL;

   void GlobalMasterToCurrTrans();
   void CurrTransToGlobalMaster();

   CHANGE_TRACK_Action action = info->action;
#if defined(DEBUG)
printf("action=%d\n",action);
#endif
/* Si creation d'un element ou destruction d'un element  */
   if (/*Fl_source == MICROSTATION && mdlCommandNumber
   &&*/
        (CHANGE_TRACK_Add == action ||
        CHANGE_TRACK_Modify == action ||
        CHANGE_TRACK_NewFPosModify == action ||
        CHANGE_TRACK_Delete == action )
      )
   {

      if (CHANGE_TRACK_Add == action ) {
         edP = new_edP;
         elP = &new_edP->el;
         #if defined(DEBUG)
         printf("CHANGE_TRACK_Add=%d\n",CHANGE_TRACK_Add);
         #endif
      }
      else if (CHANGE_TRACK_Modify == action ||
               CHANGE_TRACK_NewFPosModify == action ) {
         edP = old_edP;
         elP = &old_edP->el;
         #if defined(DEBUG)
         printf("CHANGE_TRACK_Modify=%d, CHANGE_TRACK_NewFPosModify=%d\n",CHANGE_TRACK_Modify,CHANGE_TRACK_NewFPosModify);
         #endif
      }
      else if (CHANGE_TRACK_Delete == action ) {
         edP = old_edP;
         elP = &old_edP->el;
         #if defined(DEBUG)
         printf("CHANGE_TRACK_Delete=%d\n",CHANGE_TRACK_Delete);
         #endif
      }
      filepos = mdlElmdscr_getFilePos(edP);

      elem_type = mdlElement_getType(elP);

	fl_elem_ok = 1;

      if (fl_elem_ok) {
         *cant_be_undone = TRUE;

		 // si création
         if (CHANGE_TRACK_Add == action ) {
			 // placement
            #if defined(DEBUG)
            printf("CHANGE_TRACK_Add && Undo_op == ADD\n");
            #endif
		 }
		// si modification
         else if ((CHANGE_TRACK_Modify == action ||
                   CHANGE_TRACK_NewFPosModify == action ) && 
                  (0 == Nb_elems)) {
            //modification
            #if defined(DEBUG)
            printf("Undo_op == MODIFY || Nb_elems == 0\n");
            #endif
         }
		// Si destruction,
         else if (CHANGE_TRACK_Delete == action ) {
            #if defined(DEBUG)
            printf("CHANGE_TRACK_Delete\n");
            #endif
         }
      }
   }
}

/*MAN______________________________________________________________________

NOM pgcSetSynchronizingOn: enable synchronizing DGN with PG

DESCRIPTION

SYNOPSIS
VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Public void pgcSetSynchronizingOn(char *args)
//cmdNumber CMD_PGC_SYNC_ON
{
    if (mdlCommandNumber == CMD_PGC_SYNC_ON)
    {
		mdlInput_sendKeyin("vba run [pgconnector]ModulePgconnector.pgcSynchronizingOn",0, INPUTQ_EOQ, NULL);
		/*
        mdlChangeTrack_setFunction(CHANGE_TRACK_FUNC_Changed,NULL);
        mdlChangeTrack_setFunction(CHANGE_TRACK_FUNC_Changed,undoRedoProcessAddOrChange);
        //PTS_updatePtopoCurrentSpec();
	    mdlOutput_message("Synchronisation BD spatiale activée");

	    //PTS_updatePtopoCurrentSpec();
#if defined(DEBUG)
	    printf ("PGC SYNC ON cmd=%x\n", mdlCommandNumber);
	    printf("Synchronisation BD spatiale activée\n");
#endif*/
	}
}
/*MAN______________________________________________________________________

NOM pgcSetSynchronizingOff: disable synchronizing DGN with PG

DESCRIPTION

SYNOPSIS
VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Public void pgcSetSynchronizingOff(char *args)
//cmdNumber CMD_PGC_SYNC_OFF
{
    if (mdlCommandNumber == CMD_PGC_SYNC_OFF)
    {
		mdlInput_sendKeyin("vba run [pgconnector]ModulePgconnector.pgcSynchronizingOff",0, INPUTQ_EOQ, NULL);
		/*
        mdlChangeTrack_setFunction(CHANGE_TRACK_FUNC_Changed,NULL);
		mdlOutput_message("Synchronisation BD spatiale désactivée");

        //PTS_updatePtopoCurrentSpec();
#if defined(DEBUG)
        printf ("PGC SYNC OFF cmd=%x\n", mdlCommandNumber);
		printf("Synchronisation BD spatiale désactivée\n");
#endif
*/
    }
}
/*MAN______________________________________________________________________

NOM pgcAttach: extract graphic elements from PG to postgis.dgn and add or 
reload postgis.dgn in reference of active DGN

DESCRIPTION

SYNOPSIS
VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Public void pgcAttach(char *args)
//cmdNumber CMD_PGC_ATTACH
{
mdlInput_sendKeyin("vba run [pgconnector]ModulePgconnector.pgcAttachPgLayerDialog",0, INPUTQ_EOQ, NULL);	
}

/*MAN______________________________________________________________________

NOM pgcCheckIn: insert/update graphic elements in PG

DESCRIPTION

SYNOPSIS
VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Public void pgcCheckIn(char *args)
//cmdNumber CMD_PGC_CHECKIN
{
mdlInput_sendKeyin("vba run [pgconnector]ModulePgconnector.pgcExportLevelToPgDialog",0, INPUTQ_EOQ, NULL);	
}

/*MAN______________________________________________________________________

NOM pgcCheckOut: extract graphic elements from PG for future update

DESCRIPTION

SYNOPSIS
VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Public void pgcCheckOut(char *args)
//cmdNumber CMD_PGC_CHECKOUT
{
mdlInput_sendKeyin("vba run [pgconnector]ModulePgconnector.pgcImportPgLayerDialog",0, INPUTQ_EOQ, NULL);	
}

/*MAN______________________________________________________________________

NOM pgcConnectionAdd: add a connection to PG

DESCRIPTION

SYNOPSIS
VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Public void pgcConnectionAdd(char *args)
//cmdNumber CMD_PGC_CONNECTION_ADD
{
mdlInput_sendKeyin("vba run [pgconnector]ModulePgconnector.pgcNewConnection",0, INPUTQ_EOQ, NULL);
}

/*MAN______________________________________________________________________

NOM pgcConnectionDelete: delete a connection

DESCRIPTION

SYNOPSIS
VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Public void pgcConnectionDelete(char *args)
//cmdNumber CMD_PGC_CONNECTION_DELETE
{
}

/*MAN______________________________________________________________________

NOM pgcConnect: connect to PG

DESCRIPTION

SYNOPSIS
VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Public void pgcConnect(char *args)
//cmdNumber CMD_PGC_CONNECT
{
mdlInput_sendKeyin("vba run [pgconnector]ModulePgconnector.pgcConnect",0, INPUTQ_EOQ, NULL);
}

/*MAN______________________________________________________________________

NOM pgcDisconnect: disconnect from PG

DESCRIPTION

SYNOPSIS
VOIR EGALEMENT

DIAGNOSTICS
___________________________________________________________________ENDMAN*/
Public void pgcDisconnect(char *args)
//cmdNumber CMD_PGC_DISCONNECT
{
}

/*----------------------------------------------------------------------+
|									|
| name		main							|
|									|
| author	BSI     				8/89		|
|									|
+----------------------------------------------------------------------*/
/*
Private DialogHookInfo uHooks[] =
    {
    {HOOKITEMID_LocateButton, (PFDialogHook) pgconnector_locateButtonHook},
    };
*/
Private MdlCommandNumber commandNumbers[] =
    {
    {(void (*)(char *)) pgcAttach,                      CMD_PGC_ATTACH                          },
    {(void (*)(char *)) pgcConnectionAdd,               CMD_PGC_CONNECTION_ADD                  },
    {(void (*)(char *)) pgcConnectionDelete,            CMD_PGC_CONNECTION_DELETE               },
    {(void (*)(char *)) pgcConnect,                     CMD_PGC_CONNECT                         },
    {(void (*)(char *)) pgcDisconnect,                  CMD_PGC_DISCONNECT                      },
    {(void (*)(char *)) pgcCheckIn,                     CMD_PGC_CHECKIN                         },
    {(void (*)(char *)) pgcCheckOut,                    CMD_PGC_CHECKOUT                        },
    {(void (*)(char *)) pgcSetSynchronizingOn,          CMD_PGC_SYNC_ON                         },
    {(void (*)(char *)) pgcSetSynchronizingOff,         CMD_PGC_SYNC_OFF                        },
    0           /* The table must be NULL-terminated */
    };

	/*
Private MdlCommandName commandNames[] =
    {
    {(void (*)(char *)) pgconnector_scanLabelNode,                "pgconnector_scanLabelNode"                       },
    {(void (*)(char *)) pgconnector_pushpin,                    "pgconnector_pushpin"                           },
    {(void (*)(char *)) pgconnector_loadLabelCommand,              "pgconnector_loadLabelCommand"                     },
    0           // The table must be NULL-terminated
    };
*/
extern "C" DLLEXPORT void MdlMain
(
int   argc,
char *argv[]
)
    {
    mdlSystem_registerCommandNumbers (commandNumbers);
    //mdlSystem_registerCommandNames   (commandNames);
    
    RscFileHandle   rfHandle;

    /* open our application file for access to our dialogs */
    mdlResource_openFile (&rfHandle, NULL, RSC_READ);

    if (mdlParse_loadCommandTable (NULL) != NULL)
        mdlOutput_rscPrintf (MSG_MESSAGE, NULL, MESSAGELISTID_PGCONNECTORMessages, 1);

    /* Publish the dialog item hooks
    mdlDialog_hookPublish (sizeof(uHooks)/sizeof(DialogHookInfo), uHooks);
	*/
    }

